/* ocamlyacc parser for snick */
/* this file define how parser group tokens into */
/* an abstract syntax tree defined in Snick_ast */
/*   */
/*Team Name - O'Harry the Caml:      */
 /*            - Wilkins J Leong      */
 /*            - Tuyen Quang Pham  */
 /*            - Jorge Ricardo Pardave Garcia */ 

/*define input token generated by lexer*/
%{
open Snick_ast
%}

%token <bool> BOOL_CONST
%token <int> INT_CONST
%token <string> FLOAT_CONST
%token <string> STRING_CONST
%token <string> IDENT
%token BOOL INT FLOAT 
%token ASSIGN READ WRITE 
%token VAL REF
%token LPAREN RPAREN
%token LBRAC RBRAC
%token EQ LT GT LTEQ GTEQ NONEQ
%token PLUS MINUS MUL DIVIDE
%token UMINUS
%token SEMICOLON
%token COMMA
%token DOTDOT
%token OR AND
%token NOT
%token END
%token PROC
%token WHILE DO OD
%token IF THEN ELSE FI
%token EOF /*end of program*/

/*operator associativity*/
%nonassoc EQ NONEQ LT GT LTEQ GTEQ 
%left PLUS MINUS
%left MUL DIVIDE 
%left AND OR
%nonassoc UMINUS NOT

/*parsing rule*/
%type <Snick_ast.program> program


%start program
%%


/* program is list of procedure */

program:
  | procs { {procs = List.rev $1}}
  

procs:
  | procs proc { $2 :: $1}
  | { [] }

/*procedure parse*/
proc:
  | PROC head body END { {head = $2 ; body = $3} }

/*proc head parse */
head:
  IDENT LPAREN params RPAREN 
      {begin 
          ProcHead ($1, List.rev $3);
          end}

params:
  | params param {$2 :: $1}
  | { [] }
/*paramester parsing*/
param:
  | indicator beantype IDENT {Param ($1, $2, $3)}
  | indicator beantype IDENT COMMA {Param ($1, $2, $3)}

/*paramester passing indicator*/
indicator:
  | VAL {IndiVal}
  | REF {IndiRef}
/*basic type*/
beantype :
  | BOOL { Bool }
  | INT { Int }
  | FLOAT { Float }
/*proc body*/
body:
  decls stmts {ProcBody (List.rev $1, List.rev $2)}

/*var decl*/
decls :
  | decls decl { $2 :: $1 }
  | { [] }
/*var or array decl*/
decl:
  | beantype IDENT SEMICOLON { DeclVar ($1,  $2) }
  | beantype IDENT LBRAC intervals RBRAC SEMICOLON { DecArr ($1, $2, List.rev $4)}
/* array interval */
intervals:
  | intervals interval { $2 :: $1}
  | { []}  
/* array interval */
interval:
  | INT_CONST DOTDOT INT_CONST COMMA {Interval ($1, $3)}
  | INT_CONST DOTDOT INT_CONST {Interval ($1, $3)}
/*parse statement*/
stmts: 
  | stmts stmt { $2 :: $1}
  | stmt { $1 :: [] }  

stmt:
  | astmt SEMICOLON { Atomic $1 }
  | cstmt { Composite $1 }
/*Atomic stmt*/
astmt:
  | lvalue ASSIGN rvalue { Assign ($1, $3)}  
  | READ lvalue { Read $2 }
  | WRITE expr { Write $2 }
  | IDENT LPAREN exprlist RPAREN { ProcCall ( $1, List.rev $3) }
/*Composite stmt*/
exprlist:
  | exprlist COMMA expr {$3 :: $1}
  | expr {$1 :: []}
  | { [] }
/*parse expression base precedent */
expr:
  | expr OR expr1 {Ebinop ($1, Op_or, $3)}
  | expr1 {$1}

expr1:
  | expr1 AND expr2 {Ebinop ($1, Op_and, $3)}
  | expr2 {$1}

expr2:
  | NOT expr3 {Eunop (Op_not, $2)}
  | expr3 {$1}

expr3:
  | expr3 EQ expr4 {Ebinop ($1, Op_eq, $3)}
  | expr3 NONEQ expr4 {Ebinop ($1, Op_nEq, $3)}
  | expr3 LT expr4 {Ebinop ($1, Op_lt, $3)}
  | expr3 LTEQ expr4 {Ebinop ($1, Op_ltEq, $3)}
  | expr3 GT expr4 {Ebinop ($1, Op_gt, $3)}
  | expr3 GTEQ expr4 {Ebinop ($1, Op_gtEq, $3)}
  | expr4 { $1}

expr4:
  | expr4 PLUS expr5 {Ebinop ($1, Op_add, $3)}
  | expr4 MINUS expr5 {Ebinop ($1, Op_sub, $3)}
  | expr5 {$1}

expr5: 
  | expr5 MUL expr6 {Ebinop ($1, Op_mul, $3)}
  | expr5 DIVIDE expr6 {Ebinop ($1, Op_div, $3)}
  | expr6 {$1}

expr6:
  | UMINUS expr7 {Eunop (Op_minus, $2)}
  | expr7 {$1}

expr7:
  | LPAREN expr RPAREN {$2}
  | lvalue {Elval $1}
  | const {Const $1}

/*expr list within [] cant be empty otherwise produce error*/
lvalue: 
  | IDENT { LId ( $1)}
  | IDENT LBRAC exprlist RBRAC 
          {match $3 with
              | [] -> raise (Except "empty list between []\n")
              | _ -> LField ( $1, List.rev $3)}

const:
  | BOOL_CONST { Ebool $1 }
  | INT_CONST { Eint $1 }
  | FLOAT_CONST { Efloat (float_of_string $1)}
  | STRING_CONST { EString $1}

rvalue : 
  expr { Rexpr $1 }

cstmt :
  | IF expr THEN stmts FI { IfThenFi ($2, List.rev $4)}
  | IF expr THEN stmts ELSE stmts FI {IfThenElseFi ($2, List.rev $4, List.rev $6)}
  | WHILE expr DO stmts OD {WhileDo ($2, List.rev $4)}












